<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JARVIS 3D Neural Network</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    :root {
      --bg: #050508;
      --panel-bg: rgba(10, 15, 25, 0.85);
      --border: rgba(255, 255, 255, 0.1);
      --accent: #00d4ff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg);
      color: #e0e0e0;
      font-family: 'SF Mono', 'Consolas', monospace;
      overflow: hidden;
      height: 100vh;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Sidebar and Panels */
    .sidebar-left {
      position: fixed;
      top: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      z-index: 100;
      max-height: calc(100vh - 40px);
      width: 320px;
      pointer-events: none;
    }

    .sidebar-left>* {
      pointer-events: all;
    }

    .panel {
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.25rem;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .info-panel h1 {
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      color: #fff;
    }

    .stats {
      font-size: 0.7rem;
      color: #6a7a8a;
    }

    .panel h3 {
      font-size: 0.7rem;
      color: #6a7a8a;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 0.75rem;
    }

    /* Scrollable Lists */
    .scroll-list {
      max-height: 200px;
      overflow-y: auto;
      padding-right: 5px;
    }

    ::-webkit-scrollbar {
      width: 4px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
    }

    .list-item {
      padding: 0.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 0.75rem;
      display: flex;
      justify-content: space-between;
      color: #8a9aaa;
    }

    /* Selection Info */
    .node-details {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      max-height: 30vh;
      display: none;
      z-index: 100;
      overflow-y: auto;
    }

    .node-details.visible {
      display: block;
    }

    .node-details h2 {
      color: var(--accent);
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .node-details p {
      font-size: 0.85rem;
      line-height: 1.5;
      color: #ccc;
    }

    .controls-hint {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 0.65rem;
      color: #4a5a6a;
      text-align: right;
    }

    .activity-item {
      padding: 0.4rem;
      border-left: 2px solid #2d3a4d;
      margin-bottom: 0.4rem;
      background: rgba(255, 255, 255, 0.02);
      font-size: 0.7rem;
    }

    .activity-item .time {
      color: #4a5a6a;
      font-size: 0.6rem;
      margin-bottom: 2px;
    }
  </style>
</head>

<body>
  <div id="canvas-container"></div>

  <div class="sidebar-left">
    <div class="panel info-panel">
      <h1>ü™ê JARVIS 3D Neural</h1>
      <div class="stats">
        <span id="n-count">0</span> Nodes | <span id="l-count">0</span> Synapses
      </div>
    </div>

    <div class="panel">
      <h3>Active Signals</h3>
      <div class="scroll-list" id="activityStream"></div>
    </div>

    <div class="panel">
      <h3>Neural State</h3>
      <div class="scroll-list" id="neuralState"></div>
    </div>
  </div>

  <div class="panel node-details" id="nodeInfo">
    <h2 id="nodeTitle">Select a neuron</h2>
    <p id="nodeContent">Hover or click in 3D space to explore knowledge nodes.</p>
  </div>

  <div class="controls-hint">
    LMB: Rotate | RMB: Pan | Scroll: Zoom<br>
    Hover nodes to view data
  </div>

  <script>
    const API = 'http://localhost:9124';
    const colors = {
      carsten: 0x10b981,
      jarvis: 0xa855f7,
      regeln: 0xf59e0b,
      skills: 0x00d4ff,
      projekt: 0xef4444,
      workflow: 0x6a7a8a,
      user: 0x4a5568
    };

    function detectCategory(text) {
      const t = text.toLowerCase();
      if (t.includes('carsten') || t.includes('geburtstag') || t.includes('wohnort')) return 'carsten';
      if (t.includes('jarvis') || t.includes('identit√§t') || t.includes('aufgaben')) return 'jarvis';
      if (t.includes('regel') || t.includes('fakt') || t.includes('ehrlich')) return 'regeln';
      if (t.includes('skill') || t.includes('react') || t.includes('golang')) return 'skills';
      if (t.includes('projekt') || t.includes('weiberwirtschaft')) return 'projekt';
      if (t.includes('workflow') || t.includes('plan')) return 'workflow';
      return 'user';
    }

    // Three.js Setup
    let scene, camera, renderer, controls, raycaster, mouse;
    let nodesGroup, linksGroup;
    let nodes = [], links = [];
    let hoveredMesh = null;

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050508);
      scene.fog = new THREE.FogExp2(0x050508, 0.002);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
      camera.position.z = 800;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 1);
      camera.add(pointLight);
      scene.add(camera);

      nodesGroup = new THREE.Group();
      linksGroup = new THREE.Group();
      scene.add(nodesGroup);
      scene.add(linksGroup);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      window.addEventListener('resize', onResize);
      window.addEventListener('mousemove', onMouseMove);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function addActivity(msg) {
      const el = document.getElementById('activityStream');
      const item = document.createElement('div');
      item.className = 'activity-item';
      const time = new Date().toLocaleTimeString();
      item.innerHTML = `<div class="time">${time}</div><div>${msg}</div>`;
      el.insertBefore(item, el.firstChild);
      if (el.children.length > 50) el.lastChild.remove();
    }

    async function loadData() {
      try {
        const res = await fetch(API + '/seeds/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: 'der', limit: 100, threshold: 0 })
        });
        const data = await res.json();
        updateGraph(data.results || []);
      } catch (e) {
        console.error(e);
      }
    }

    function updateGraph(seeds) {
      const newNodes = seeds.map(s => {
        const cat = detectCategory(s.content);
        return {
          id: s.seedId,
          content: s.content,
          category: cat,
          color: colors[cat]
        };
      });

      // Simple 3D Spherical Distribution for new items
      newNodes.forEach((node, i) => {
        const existing = nodes.find(n => n.id === node.id);
        if (!existing) {
          const phi = Math.acos(-1 + (2 * i) / newNodes.length);
          const theta = Math.sqrt(newNodes.length * Math.PI) * phi;
          const radius = 300 + Math.random() * 200;

          node.x = radius * Math.cos(theta) * Math.sin(phi);
          node.y = radius * Math.sin(theta) * Math.sin(phi);
          node.z = radius * Math.cos(phi);
          node.vx = 0; node.vy = 0; node.vz = 0;
          nodes.push(node);

          // Add Mesh
          const geo = new THREE.SphereGeometry(6, 16, 16);
          const mat = new THREE.MeshPhongMaterial({
            color: node.color,
            emissive: node.color,
            emissiveIntensity: 0.5,
            shininess: 100
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(node.x, node.y, node.z);
          mesh.userData = node;
          nodesGroup.add(mesh);
          node.mesh = mesh;

          addActivity(`Nucleus #${node.id} materialisiert`);
        }
      });

      // Update Links
      linksGroup.clear();
      links = [];
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const a = nodes[i], b = nodes[j];
          const dist = Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
          if (dist < 250 || (a.category === b.category && dist < 400)) {
            links.push({ source: i, target: j, dist });

            const points = [new THREE.Vector3(a.x, a.y, a.z), new THREE.Vector3(b.x, b.y, b.z)];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
              color: a.color,
              transparent: true,
              opacity: 0.2
            });
            const line = new THREE.Line(geometry, material);
            linksGroup.add(line);
          }
        }
      }

      document.getElementById('n-count').textContent = nodes.length;
      document.getElementById('l-count').textContent = links.length;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // Simple 3D Physics (Attraction to center and repulsion)
      nodes.forEach(n => {
        // Center force
        n.vx -= n.x * 0.0001;
        n.vy -= n.y * 0.0001;
        n.vz -= n.z * 0.0001;

        // Repulsion
        nodes.forEach(m => {
          if (n === m) return;
          const dx = n.x - m.x, dy = n.y - m.y, dz = n.z - m.z;
          const distSq = dx * dx + dy * dy + dz * dz;
          if (distSq < 10000) {
            const force = 0.5 / (distSq + 1);
            n.vx += dx * force; n.vy += dy * force; n.vz += dz * force;
          }
        });

        n.x += n.vx; n.y += n.vy; n.z += n.vz;
        n.vx *= 0.95; n.vy *= 0.95; n.vz *= 0.95;

        if (n.mesh) n.mesh.position.set(n.x, n.y, n.z);
      });

      // Raycasting for hover
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(nodesGroup.children);

      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (hoveredMesh !== obj) {
          if (hoveredMesh) hoveredMesh.scale.set(1, 1, 1);
          hoveredMesh = obj;
          hoveredMesh.scale.set(2, 2, 2);

          const data = obj.userData;
          document.getElementById('nodeInfo').classList.add('visible');
          document.getElementById('nodeTitle').textContent = `Nucleus #${data.id} [${data.category.toUpperCase()}]`;
          document.getElementById('nodeContent').textContent = data.content;
        }
      } else {
        if (hoveredMesh) hoveredMesh.scale.set(1, 1, 1);
        hoveredMesh = null;
        // Don't hide info immediately to allow reading
      }

      renderer.render(scene, camera);
    }

    initThree();
    loadData();
    animate();
    setInterval(loadData, 15000);
  </script>
</body>

</html>